{"version":3,"file":"blocktron_node.js","sources":["webpack://blocktron-node/webpack/bootstrap","webpack://blocktron-node/./bin/server.js","webpack://blocktron-node/./config/blocktron.js","webpack://blocktron-node/./config/pino.js","webpack://blocktron-node/./config/pinoPretty.js","webpack://blocktron-node/./src/app.js","webpack://blocktron-node/./src/lib/blocktron.js","webpack://blocktron-node/./src/middlewares/index.js","webpack://blocktron-node/./src/middlewares/response.js","webpack://blocktron-node/./src/routes/blocktron.js","webpack://blocktron-node/./src/routes/broadcastTransaction.js","webpack://blocktron-node/./src/routes/consensus.js","webpack://blocktron-node/./src/routes/index.js","webpack://blocktron-node/./src/routes/mine.js","webpack://blocktron-node/./src/routes/receiveNewBlock.js","webpack://blocktron-node/./src/routes/registerAndBroadcastNode.js","webpack://blocktron-node/./src/routes/registerNode.js","webpack://blocktron-node/./src/routes/registerNodesBulk.js","webpack://blocktron-node/./src/routes/transaction.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./bin/server.js\");\n","'use strict';\n\n/**\r\n * Module dependencies.\r\n * @module Server\r\n */\n\n/**\r\n * The blocktronNode instance\r\n */\nvar blocktronNode = require('../src/app');\n\n/**\r\n * A tiny JavaScript debugging utility modelled after Node.js core's debugging technique.\r\n * Works in Node.js and web browsers.\r\n */\nvar debug = require('debug')('blocktron-node:server');\n\n/**\r\n * Node module housing the traditional complex http interfaces.\r\n */\nvar http = require('http');\n\n/**\r\n * Get port from environment and store in Express.\r\n */\nvar port = normalizePort(process.argv[2] || _bt_config.defaultAppPort);\nglobal.port = port;\nblocktronNode.set('port', port);\n\n/**\r\n * Create HTTP server.\r\n */\nvar server = http.createServer(blocktronNode);\n\n/**\r\n * Listen on provided port, on all network interfaces.\r\n */\nserver.listen(port, function () {\n   log.info('Blocktron is running on port: ' + port);\n});\nserver.on('error', onError);\nserver.on('listening', onListening);\n\n/**\r\n * Normalize a port into a number, string, or false.\r\n * @function\r\n * @name normalizePort\r\n * @memberof Server\r\n * @param {Number} val - The port number or string\r\n * @returns {Number|String|Boolean} - Returns number, string, or false\r\n */\nfunction normalizePort(val) {\n   var port = parseInt(val, 10);\n\n   if (isNaN(port)) {\n      // named pipe\n      return val;\n   }\n\n   if (port >= 0) {\n      // port number\n      return port;\n   }\n\n   return false;\n}\n\n/**\r\n * Event listener for HTTP server \"error\" event.\r\n * @function\r\n * @name onError\r\n * @memberof Server\r\n * @param {Object} error - The error event object\r\n * @returns - Returns the error\r\n */\nfunction onError(error) {\n   if (error.syscall !== 'listen') {\n      throw error;\n   }\n\n   var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port;\n\n   // handle specific listen errors with friendly messages\n   switch (error.code) {\n      case 'EACCES':\n         console.error(bind + ' requires elevated privileges');\n         process.exit(1);\n         break;\n      case 'EADDRINUSE':\n         console.error(bind + ' is already in use');\n         process.exit(1);\n         break;\n      default:\n         throw error;\n   }\n}\n\n/**\r\n * Event listener for HTTP server \"listening\" event.\r\n * @function\r\n * @name onListening\r\n * @memberof Server\r\n */\nfunction onListening() {\n   var addr = server.address();\n   var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;\n   debug('Listening on ' + bind);\n}","'use strict';\n\n/**\r\n * Blocktron global configuration\r\n * @module _bt_config\r\n */\n\n/**\r\n * A node module for simple, fast generation of RFC4122 UUIDS.\r\n * Here v1 is used.\r\n * @see {@link https://www.ietf.org/rfc/rfc4122.txt|RFC4122}\r\n */\nvar uuid = require('uuid/v1');\n\n/**\r\n * Generate an RFC4122 compatible unique distributed-system node identifier.\r\n * Using uuid generate a unique string, then remove the dashes in the string and rejoin them.\r\n * The string generated is guarenteed to be unique at a very high percentage.\r\n */\nvar blocktronNodeId = uuid().split('-').join('');\n\n/**\r\n * Blocktron configuration object\r\n * @type {Object}\r\n * @memberof _bt_config\r\n * @inner\r\n * @param {String} appTitle - The global process title\r\n * @param {Number} defaultAppPort - The default port for the app to run\r\n * @param {String} blocktronNodeId - The unique identifier for a single instance of this app\r\n * @param {String} rewardSenderAddress - The address label for this particular instance for reward process\r\n * @param {Number} rewardValue - The default global reward value\r\n * @param {Number} difficulty - The default 'DIFFICULTY' value\r\n * @param {Number} mineRate - The default mine rate in milli seconds\r\n */\nvar _bt_config = {\n  appTitle: 'Blocktron Node',\n  defaultAppPort: 3000,\n  blocktronNodeId: blocktronNodeId,\n  rewardSenderAddress: '00BLOCKTRON',\n  rewardValue: 12.5,\n  difficulty: 4,\n  mineRate: 4000\n};\n\nmodule.exports = _bt_config;","'use strict';\n\n/**\r\n * Pino Logger configuration\r\n * This module holds the complete configuration object for the Pino logger instance\r\n * @module pinoConfig\r\n * @see {@link https://github.com/pinojs/pino/blob/master/docs/API.md|Pino Config}\r\n */\n\nvar pinoPrettyConfig = require('./pinoPretty');\n\nvar pinoConfig = {\n  /**\r\n   * safe (boolean): avoid error caused by circular references in the object tree. Default: true.\r\n   * */\n  safe: true,\n\n  /**\r\n   * name (string): the name of the logger. Default: undefined.\r\n   * */\n  name: 'blocktron',\n\n  /**\r\n   * timestamp (boolean|function): Enables or disables the inclusion of a timestamp in the log message. If a function\r\n   * is supplied, it must synchronously return a JSON string representation of the time, e.g. ,\"time\":1493426328206\r\n   * (which is the default). If set to false, no timestamp will be included in the output. See stdTimeFunctions for a\r\n   * set of available functions for passing in as a value for this option. Caution: any sort of formatted time will\r\n   * significantly slow down Pino's performance.\r\n   */\n  timestamp: true,\n\n  /**\r\n   * slowtime (boolean): Outputs ISO time stamps ('2016-03-09T15:18:53.889Z') instead of Epoch time stamps\r\n   * (1457536759176). WARNING: This option carries a 25% performance drop. We recommend using default Epoch\r\n   * timestamps and transforming logs after if required. The pino -t command will do this for you (see CLI).\r\n   * Default: false.\r\n   * Deprecation: this option is scheduled to be removed in Pino 5.0.0.\r\n   * Use timestamp: pino.stdTimeFunctions.slowTime instead.\r\n   */\n  slowtime: false,\n\n  /**\r\n   * level (string): one of 'fatal', 'error', 'warn', 'info', 'debug', 'trace'; also 'silent' is supported to disable\r\n   * logging. Any other value defines a custom level and requires supplying a level value via levelVal.\r\n   * Default: 'info'.\r\n   */\n  level: 'info',\n\n  /**\r\n   * messageKey (string): the string key for the 'message' in the JSON object. Default msg.\r\n   */\n  messageKey: 'msg',\n\n  /**\r\n   * prettyPrint (boolean|object): enables pino.pretty. This is intended for non-production configurations.\r\n   * This may be set to a configuration object as outlined in pino.pretty. Default: false.\r\n   */\n  prettyPrint: pinoPrettyConfig,\n\n  /**\r\n   * enabled (boolean): enables logging. Default: true\r\n   */\n  enabled: true\n};\n\nmodule.exports = pinoConfig;","'use strict';\n\n/**\r\n * Pino-Pretty configuration object\r\n * @see {@link https://github.com/pinojs/pino-pretty | Pino-Pretty-github}\r\n */\nvar options = {\n   colorize: true,\n   crlf: true,\n   errorLikeObjectKeys: ['err', 'error'],\n   errorProps: '',\n   levelFirst: false,\n   localTime: false,\n   messageKey: 'msg',\n   translateTime: false\n};\n\nmodule.exports = options;","'use strict';\n\n/**\n * blocktron-node\n * The Blocktron blockchain API Server Node.\n * This server acts as the single node in the entire distributed blockchain system.\n * Written by: Sandeep Vattapparambil\n * Email: sandeepv68@gmail.com\n * Website: www.sandeepv.in\n */\n\n/**\n * The blocktron-node express application object\n * @module blocktronNode\n */\n\n/**\n * Global blocktron configuration\n * @global\n */\nvar _bt_config = require('../config/blocktron');\nglobal._bt_config = _bt_config;\n\n/**\n * Set up process environment\n * @global\n */\nvar env = process.env.NODE_ENV || 'development';\nglobal.env = env;\n\n/**\n * Set up process title (useful for debugging)\n */\nprocess.title = _bt_config.appTitle;\n\n/**\n * Create HTTP errors for Express, Koa, Connect, etc. with ease.\n */\nvar createError = require('http-errors');\n\n/**\n * Fast, unopinionated, minimalist web framework for node.\n */\nvar express = require('express');\n\n/**\n * Pino instance: Extremely fast node.js logger, inspired by Bunyan.\n * It also includes a shell utility to pretty-print its log files.\n * @global\n */\nvar log = require('pino')(require('../config/pino'));\n\n/**\n * Set up global logging\n */\nglobal.log = log;\n\n/**\n * Include the blocktron library (after it has been extended)\n */\nvar Blocktron = require('./lib/blocktron');\n\n/**\n * Create an instance of the Blocktron class and globalize it.\n * @global\n */\nvar blocktron = new Blocktron();\nglobal.blocktron = blocktron;\n\n/**\n * Set-up routes\n */\nvar indexRouter = require('./routes/index');\nvar blocktronRouter = require('./routes/blocktron');\nvar transactionRouter = require('./routes/transaction');\nvar mineRouter = require('./routes/mine');\nvar registerAndBroadCastNodeRouter = require('./routes/registerAndBroadcastNode');\nvar registerNodeRouter = require('./routes/registerNode');\nvar registerNodesBulkRouter = require('./routes/registerNodesBulk');\nvar broadcastTransactionRouter = require('./routes/broadcastTransaction');\nvar receiveNewBlockRouter = require('./routes/receiveNewBlock');\nvar consensusRouter = require('./routes/consensus');\nlog.info('Blocktron routes initialized');\n\n/**\n * Instantiate the blocktron express app object\n */\nvar blocktronNode = express();\nlog.info('Blocktron initialized and running in ' + env + ' mode');\n\n/**\n * disable x-powered-by to deceive hackers\n */\nblocktronNode.disable('x-powered-by');\n\n/**\n * Set-up and use middlewares\n * @memberof blocktronNode\n */\nblocktronNode.use(express.json());\nblocktronNode.use(express.urlencoded({\n  extended: false\n}));\nlog.info('Blocktron application middlewares initialized');\n\n/**\n * Custom Middlewares\n * @memberof blocktronNode\n */\nblocktronNode.use(require('./middlewares'));\nlog.info('Blocktron custom middlewares initialized');\n\n/**\n * Add routes to the middleware chain\n * @memberof blocktronNode\n */\nblocktronNode.use('/', indexRouter);\nblocktronNode.use('/docs', express.static('docs'));\nblocktronNode.use('/blockchain', blocktronRouter);\nblocktronNode.use('/transaction', transactionRouter);\nblocktronNode.use('/mine', mineRouter);\nblocktronNode.use('/registerAndBroadcastNode', registerAndBroadCastNodeRouter);\nblocktronNode.use('/registerNode', registerNodeRouter);\nblocktronNode.use('/registerNodesBulk', registerNodesBulkRouter);\nblocktronNode.use('/transaction/broadcast', broadcastTransactionRouter);\nblocktronNode.use('/receiveNewBlock', receiveNewBlockRouter);\nblocktronNode.use('/consensus', consensusRouter);\nlog.info('Blocktron routes chained to middlewares');\n\n/**\n * Catch 404 and forward to error handler\n * @memberof blocktronNode\n * @function\n * @param {Callback} middleware - Callback to catch 404 error\n */\nblocktronNode.use(function (req, res, next) {\n  log.error('Error caught');\n  next(createError(404));\n});\n\n/**\n * Error handler\n * @memberof blocktronNode\n * @function\n * @param {Callback} middleware - Callback to render the error\n */\nblocktronNode.use(function (err, req, res, next) {\n  /**\n   * render the error\n   */\n  res.status(err.status || 500);\n  var errorData = {\n    status: err.status || 500,\n    message: err.message\n  };\n  if (env === 'development') {\n    errorData.stack = err.stack;\n  }\n  log.error(req, res);\n  res.json(errorData);\n});\n\nmodule.exports = blocktronNode;","'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * A module to enhance the blocktron-lib data structure library\r\n */\n\n/**\r\n * Import the original blocktron-lib\r\n */\nvar BlocktronLib = require('blocktron-lib');\n\n/**\r\n * A node module for simple, fast generation of RFC4122 UUIDS.\r\n * Here v1 is used.\r\n * @see {@link https://www.ietf.org/rfc/rfc4122.txt|RFC4122}\r\n */\nvar uuid = require('uuid/v1');\n\n/**\r\n * Get the current node's url from command-line args array position 3\r\n */\nvar currentNodeUrl = void 0;\n// if (process.argv[3]) {\n//   currentNodeUrl = process.argv[3];\n// } else {\n//   log.info('Node URL argument is missing');\n// }\ncurrentNodeUrl = process.argv[3] ? process.argv[3] : '';\n\n/**\r\n * Import global blocktron configuration\r\n */\nvar _bt_config = require('../../config/blocktron');\n\n/**\r\n * The blocktron-lib class enhanced\r\n * @class Blocktron\r\n * @classdesc A module to enhance the blocktron-lib data structure library\r\n * @extends BlocktronLib\r\n */\n\nvar Blocktron = function (_BlocktronLib) {\n  _inherits(Blocktron, _BlocktronLib);\n\n  /**\r\n   * The constructor for the class\r\n   * @param {Array} chain - The blockchain array\r\n   * @param {Array} pendingTransactions - The pending transactions array\r\n   */\n  function Blocktron(chain, pendingTransactions) {\n    _classCallCheck(this, Blocktron);\n\n    /**\r\n     * Add the current node's url as a property\r\n     */\n    var _this = _possibleConstructorReturn(this, (Blocktron.__proto__ || Object.getPrototypeOf(Blocktron)).call(this, chain, pendingTransactions));\n    /**\r\n     * Call the parent class constructor with the given parameters.\r\n     */\n\n\n    _this.currentNodeUrl = currentNodeUrl;\n\n    /**\r\n     * Add url's of all other nodes in the distributed system\r\n     */\n    _this.networkNodes = [];\n    return _this;\n  }\n\n  /**\r\n   * Helper prototype to check whether a node url already exists in the networkNodes array.\r\n   * @function isNewNode\r\n   * @memberof Blocktron\r\n   * @param {String} nodeUrl - The url of the new node to register\r\n   * @returns {Boolean} - Returns true if url not present or else false\r\n   */\n\n\n  _createClass(Blocktron, [{\n    key: 'isNewNode',\n    value: function isNewNode(nodeUrl) {\n      if (this.networkNodes.indexOf(nodeUrl) === -1) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    /**\r\n     * A method to create a new transaction\r\n     * @function createNewTransaction\r\n     * @override\r\n     * @memberof Blocktron\r\n     * @param {Number} amount - The amount/value to be recorded\r\n     * @param {String} sender - The adress of the sender\r\n     * @param {String} receiver - The address of the receiver\r\n     * @returns {Object} - Returns the transaction object\r\n     */\n\n  }, {\n    key: 'createNewTransaction',\n    value: function createNewTransaction(amount, sender, receiver) {\n      /**\r\n       * Validate the parameters\r\n       */\n      amount = amount ? amount : function () {\n        throw new Error('Amount required');\n      }();\n      sender = sender ? sender : function () {\n        throw new Error('Sender required');\n      }();\n      receiver = receiver ? receiver : function () {\n        throw new Error('receiver required');\n      }();\n\n      /**\r\n       * @type {Object}\r\n       * @const newTransactions - An atomic transactions block in the chain\r\n       * @property {String} transactionId - The unique id for a transaction\r\n       * @property {Number} amount - The value/amount to be recorded\r\n       * @property {String} sender - The adress of the sender\r\n       * @property {String} receiver - The address of the receiver\r\n       */\n      var newTransactions = {\n        transactionId: uuid().split('-').join(''),\n        amount: amount,\n        sender: sender,\n        receiver: receiver\n      };\n\n      /**\r\n       * Return the new transaction object\r\n       */\n      return newTransactions;\n    }\n\n    /**\r\n     * A blockchain method to add a newly created block to the pending transactions array\r\n     * @function addTransactionToPendingTransaction\r\n     * @memberof Blocktron\r\n     * @param {Object} transactionObject - The object representing the transaction data\r\n     */\n\n  }, {\n    key: 'addTransactionToPendingTransaction',\n    value: function addTransactionToPendingTransaction(transactionObject) {\n      /**\r\n       * Validate transaction data object\r\n       */\n      if (transactionObject) {\n        /**\r\n         * If valid, push the transaction data to the pending transactions array\r\n         */\n        this.pendingTransactions.push(transactionObject);\n\n        /**\r\n         * Then return the chronological index of the transaction data block\r\n         */\n        return this.getLastBlock()['index'] + 1;\n      } else {\n        /**\r\n         * Log error\r\n         */\n        log.error('Transaction data required');\n      }\n    }\n\n    /**\r\n     * A blockchain method to validate a blockchain\r\n     * @function isChainValid\r\n     * @memberof Blocktron\r\n     * @param {Array} chain - The array representing the blockchain data\r\n     */\n\n  }, {\n    key: 'isChainValid',\n    value: function isChainValid(chain) {\n      /**\r\n       * Validate the parameter\r\n       */\n      if (chain) {\n        /**\r\n         * Assume the blockchain is valid\r\n         */\n        var validChain = true;\n\n        /**\r\n         * Iterate the blockchain array\r\n         * Start from 1st position inorder to exclude the genesis block.\r\n         * Genesis block will be validated separetely.\r\n         */\n        for (var i = 1; i < chain.length; i++) {\n          /**\r\n           * Get current block\r\n           */\n          var currentBlock = chain[i];\n\n          /**\r\n           * Get previous block\r\n           */\n          var previousBlock = chain[i - 1];\n\n          /**\r\n           * Rehash the current block data using the parameters\r\n           */\n          var blockHash = this.hashBlock(previousBlock['hash'], {\n            transactions: currentBlock['transactions'],\n            index: currentBlock['index']\n          }, currentBlock['nonce']);\n\n          /**\r\n           * Check the generated hash for substring difficulty pattern (default is '0000')\r\n           */\n          if (blockHash.substring(0, _bt_config.difficulty) !== '0'.repeat(_bt_config.difficulty)) {\n            /**\r\n             * If not, then chain is invalid\r\n             */\n            validChain = false;\n          }\n\n          /**\r\n           * If hash values don't match between blocks\r\n           */\n          if (currentBlock['previousHash'] !== previousBlock['hash']) {\n            /**\r\n             * then chain is invalid\r\n             */\n            validChain = false;\n          }\n        }\n\n        /**\r\n         * Get the genesis block from array index 0\r\n         */\n        var genesisBlock = chain[0];\n\n        /**\r\n         * Validate genesis block's nonce\r\n         */\n        var validNonce = genesisBlock['nonce'] === 1;\n\n        /**\r\n         * Validate genesis block's previousBlockHash\r\n         */\n        var validPreviousBlockHash = genesisBlock['previousHash'] === '0';\n\n        /**\r\n         * Validate genesis block's hash\r\n         */\n        var validHash = genesisBlock['hash'] === '0';\n\n        /**\r\n         * Validate genesis block's transactions\r\n         */\n        var validTransactions = genesisBlock['transactions'].length === 0;\n\n        /**\r\n         * Check all validation parameters for genesis block\r\n         */\n        if (!validNonce || !validPreviousBlockHash || !validHash || !validTransactions) {\n          /**\r\n           * Set invalid if any parameter is invalid\r\n           */\n          validChain = false;\n        }\n\n        /**\r\n         * If genesis block and the entire chain is valid then return validChain as true.\r\n         */\n        return validChain;\n      } else {\n        /**\r\n         * Log error\r\n         */\n        log.error('Blockchain data required');\n      }\n    }\n  }]);\n\n  return Blocktron;\n}(BlocktronLib);\n\nmodule.exports = Blocktron;","'use strict';\n\n/**\r\n * Custom middlewares can be augmented here\r\n * @module middlewareRouter\r\n */\nvar express = require('express');\nvar middlewareRouter = express.Router();\n\n/**\r\n * Middleware to augment the response object with helpers\r\n * @function\r\n * @memberof middlewareRouter\r\n * @param {Middleware} middleware - Express middleware callback\r\n */\nmiddlewareRouter.use(require('./response'));\n\nmodule.exports = middlewareRouter;","'use strict';\n\n/**\r\n * The res object represents the HTTP response that an Express app sends when it gets an HTTP request.\r\n * @namespace res\r\n */\n\n/**\r\n * @module enhanceResponse\r\n */\n\n/**\r\n * Helper function to enhance the response object\r\n * @function enhanceResponse\r\n * @param {req} req - The request object\r\n * @param {res} res - The response object\r\n * @param {function} next - The next function in the middleware chain\r\n */\nvar enhanceResponse = function enhanceResponse(req, res, next) {\n   /**\r\n    * Helper function to append the CORS headers to enable CORS.\r\n    * Cross-Origin Resource Sharing (CORS) is a mechanism that uses additional\r\n    * HTTP headers to tell a browser to let a web application running at one\r\n    * origin (domain) have permission to access selected resources from a server\r\n    * at a different origin. A web application makes a cross-origin HTTP request\r\n    * when it requests a resource that has a different origin (domain, protocol, and port)\r\n    * than its own origin.\r\n    * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS|Cross-Origin Resource Sharing (CORS)}\r\n    * @function enableCORS\r\n    * @inner\r\n    */\n   (function enableCORS() {\n      try {\n         res.header('Access-Control-Allow-Origin', '*');\n         res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');\n         res.header('Access-Control-Allow-Headers', 'Content-Type');\n      } catch (error) {\n         log.error('CORS setup failed due to: ' + error);\n      }\n   })();\n\n   /**\r\n    * Helper function to append the specified value to the HTTP response header field.\r\n    * If the header is not already set, it creates the header with the specified value.\r\n    * The value parameter can be a string or an array.\r\n    * @function appendHeader\r\n    * @inner\r\n    */\n   (function appendHeader() {\n      try {\n         res.append('x-powered-by', 'blocktron');\n         res.append('x-blocktron-Accept-Charset', 'UTF-8');\n         res.append('x-blocktron-Accept-Language', 'en');\n         res.append('x-blocktron-response-timestamp', '' + Date.now());\n         res.append('x-blocktron-host-uuid', '' + _bt_config.blocktronNodeId);\n      } catch (error) {\n         log.error('Header appendage failed due to: ' + error);\n      }\n   })();\n   next();\n};\n\nmodule.exports = enhanceResponse;","'use strict';\n\n/**\r\n * blocktron router and controller\r\n * @module routers:blocktronRouter\r\n */\nvar express = require('express');\nvar blocktronRouter = express.Router();\n\n/**\r\n * GET blocktron blockchain listing.\r\n * @function\r\n * @name get/blocktron\r\n * @memberof routers:blocktronRouter\r\n * @param {String} path - Express route path\r\n * @param {Callback} middleware - Express middleware callback\r\n */\nblocktronRouter.get('/', function (req, res, next) {\n  /**\r\n   * Send the JSON representation of blockchain to the client.\r\n   */\n  res.json(blocktron);\n});\n\nmodule.exports = blocktronRouter;","'use strict';\n\n/**\r\n * blocktron transaction router and controller\r\n * @module routers:broadcastTransactionRouter\r\n */\nvar express = require('express');\nvar broadcastTransactionRouter = express.Router();\n\n/**\r\n * The simplified HTTP request client 'request' with Promise support.\r\n * Powered by Bluebird.\r\n * `request-promise` returns regular Promises/A+ compliant promises\r\n * and can be assimilated by any compatible promise library.\r\n * @see {@link https://www.npmjs.com/package/request-promise|Request-Promise}\r\n */\nvar request = require('request-promise');\n\n/**\r\n * POST a trnasaction to broadcast it\r\n * @function\r\n * @name post/broadcastTransaction\r\n * @memberof routers:broadcastTransactionRouter\r\n * @param {String} path - Express route path\r\n * @param {Callback} middleware - Express middleware callback\r\n */\nbroadcastTransactionRouter.post('/', function (req, res, next) {\n  /**\r\n   * Validate the transaction parameters\r\n   */\n  if (!req || !req.body || !req.body.amount || !req.body.sender || !req.body.receiver) {\n    /**\r\n     * log error\r\n     */\n    log.error('Cannot create a transaction without required parameters');\n  }\n\n  /**\r\n   * Create a transaction with the request parameters.\r\n   */\n  var newTransaction = blocktron.createNewTransaction(req.body.amount, req.body.sender, req.body.receiver);\n\n  /**\r\n   * Add the transaction object to pending transactions array of this node\r\n   */\n  blocktron.addTransactionToPendingTransaction(newTransaction);\n\n  /**\r\n   * Array to hold the request promise objects\r\n   */\n  var requestPromises = [];\n\n  /**\r\n   * Broadcast transactions to all nodes in the network node array\r\n   */\n  blocktron.networkNodes.forEach(function (networkNodeUrl) {\n    /**\r\n     * Construct the request\r\n     */\n    var requestOptions = {\n      uri: networkNodeUrl + '/transaction',\n      method: 'POST',\n      body: newTransaction,\n      json: true\n    };\n\n    /**\r\n     * Push request promise objects into request promise array\r\n     */\n    requestPromises.push(request(requestOptions));\n  });\n\n  /**\r\n   * Resolve all request promise objects and then send appropriate response\r\n   */\n  Promise.all(requestPromises)\n\n  /**\r\n   * Once resolved send the response\r\n   */\n  .then(function (data) {\n    /**\r\n     * Set success, object created status code\r\n     */\n    res.status(201);\n\n    /**\r\n     * Construct the response and send it\r\n     */\n    var response = {\n      status: 'success',\n      code: res.statusCode,\n      message: 'Transaction created and broadcasted successfully'\n    };\n    res.json(response);\n  }).catch(function (error) {\n    log.error('Transaction broadcast failed due to: ' + error);\n  });\n});\n\nmodule.exports = broadcastTransactionRouter;","'use strict';\n\n/**\r\n * Consensus router and controller\r\n * @module routers:consensusRouter\r\n */\nvar express = require('express');\nvar consensusRouter = express.Router();\n\n/**\r\n * The simplified HTTP request client 'request' with Promise support.\r\n * Powered by Bluebird.\r\n * `request-promise` returns regular Promises/A+ compliant promises\r\n * and can be assimilated by any compatible promise library.\r\n * @see {@link https://www.npmjs.com/package/request-promise|Request-Promise}\r\n */\nvar request = require('request-promise');\n\n/**\r\n * Check for consensus and update blockchains\r\n * This implementation uses the popular 'Longest chain rule' algorithm.\r\n * @function\r\n * @name get/consensus\r\n * @memberof routers:consensusRouter\r\n * @param {String} path - Express route path\r\n * @param {Callback} middleware - Express middleware callback\r\n */\nconsensusRouter.get('/', function (req, res, next) {\n  /**\r\n   * Array to hold the request promise objects\r\n   */\n  var requestPromises = [];\n\n  /**\r\n   * Broadcast transactions to all nodes in the network node array\r\n   */\n  blocktron.networkNodes.forEach(function (networkNodeUrl) {\n    /**\r\n     * Construct the request\r\n     */\n    var requestOptions = {\n      uri: networkNodeUrl + '/blockchain',\n      method: 'GET',\n      json: true\n    };\n\n    /**\r\n     * Push request promise objects into request promise array\r\n     */\n    requestPromises.push(request(requestOptions));\n  });\n\n  /**\r\n   * Resolve all request promise objects and then send appropriate response\r\n   */\n  Promise.all(requestPromises)\n\n  /**\r\n   * Once resolved, do chain validation and update chains accordingly\r\n   */\n  .then(function (blockchains) {\n    /**\r\n     * Get the length of the current node's blockchain\r\n     */\n    var currentChainLength = blocktron.chain.length;\n\n    /**\r\n     * Set currentChainLength as the maximum chain length\r\n     */\n    var maximumChainLength = currentChainLength;\n\n    /**\r\n     * Initialize new longest chain as null\r\n     */\n    var newLongestChain = null;\n\n    /**\r\n     * Initialize new pending transactions as null\r\n     */\n    var newPendingTransactions = null;\n\n    /**\r\n     * Iterate through each blockchain\r\n     */\n    blockchains.forEach(function (blockchain) {\n      /**\r\n       * If any blockchain has length larger than current node's blockchain\r\n       */\n      if (blockchain.chain.length > maximumChainLength) {\n        /**\r\n         * Replace new maximum chain length with largest blockchain length\r\n         */\n        maximumChainLength = blockchain.chain.length;\n\n        /**\r\n         * Replace largest blockchain as the new longest chain\r\n         */\n        newLongestChain = blockchain.chain;\n\n        /**\r\n         * Replace pending transactions list with the largest blockchain's pending transactions list\r\n         */\n        newPendingTransactions = blockchain.pendingTransactions;\n      }\n    });\n\n    /**\r\n     * If there are no long chains or the new longest chain is not a valid chain, then\r\n     * Send appropriate response\r\n     */\n    if (!newLongestChain || newLongestChain && !blocktron.isChainValid(newLongestChain)) {\n      /**\r\n       * Log error in case of consensus failure\r\n       */\n      log.error('Current blockchain has not been replaced');\n\n      /**\r\n       * Set appropriate status\r\n       */\n      res.status(200);\n\n      /**\r\n       * Construct the response object and send it\r\n       * @const response\r\n       * @type {Object}\r\n       * @memberof routers:consensusRouter\r\n       * @param {String} status - The status of the operation\r\n       * @param {Number} code - The HTTP response status code\r\n       * @param {String} message - The message string\r\n       * @param {Object} blockchain - The blockchain data\r\n       */\n      var response = {\n        status: 'Not Modified',\n        code: res.statusCode,\n        message: 'Current blockchain has not been replaced',\n        blockchain: blocktron.chain\n      };\n      res.json(response);\n    } else if (newLongestChain && blocktron.isChainValid(newLongestChain)) {\n      /**\r\n       * If there is a longer valid chain, then replace current node's blockchain with\r\n       * the longest valid chain\r\n       */\n      blocktron.chain = newLongestChain;\n\n      /**\r\n       * Update the pending transactions list of current node with the new valid\r\n       * blockchain's pending transactions list\r\n       */\n      blocktron.pendingTransactions = newPendingTransactions;\n\n      /**\r\n       * Set appropriate status code\r\n       */\n      res.status(201);\n\n      /**\r\n       * Construct the response object and send it\r\n       * @const response\r\n       * @type {Object}\r\n       * @memberof routers:consensusRouter\r\n       * @param {String} status - The status of the operation\r\n       * @param {Number} code - The HTTP response status code\r\n       * @param {String} message - The message string\r\n       * @param {Object} blockchain - The blockchain data after consensus\r\n       */\n      var _response = {\n        status: 'Chain replaced',\n        code: res.statusCode,\n        message: 'Current blockchain has been replaced',\n        blockchain: blocktron.chain\n      };\n      res.json(_response);\n    }\n  }).catch(function (error) {\n    /**\r\n     * Log error in case of consensus failure\r\n     */\n    log.error('Consensus check failed due to: ' + error);\n  });\n});\n\nmodule.exports = consensusRouter;","'use strict';\n\n/**\r\n * Index router and controller\r\n * @module routers:indexRouter\r\n */\nvar express = require('express');\nvar indexRouter = express.Router();\n\n/**\r\n * GET home page.\r\n * @function\r\n * @name get/\r\n * @memberof routers:indexRouter\r\n * @param {String} path - Express route path\r\n * @param {Callback} middleware - Express middleware callback\r\n */\nindexRouter.get('/', function (req, res, next) {\n   /**\r\n    * Construct response and send it\r\n    * This object contains information about various environment\r\n    * and configuration details of blocktron node\r\n    * @const response\r\n    * @type {Object}\r\n    * @memberof routers:indexRoute\r\n    */\n   var response = {\n      message: 'Blocktron Node is running',\n      port: port,\n      status_code: res.statusCode,\n      configuration: {\n         process_title: process.title,\n         process_pid: process.pid,\n         memory: {\n            resident_set_size: process.memoryUsage().rss / 1024 / 1024 * 100 / 100 + ' MB',\n            heap_total: process.memoryUsage().heapTotal / 1024 / 1024 * 100 / 100 + ' MB',\n            heap_used: process.memoryUsage().heapUsed / 1024 / 1024 * 100 / 100 + ' MB',\n            external: process.memoryUsage().external / 1024 / 1024 * 100 / 100 + ' MB'\n         },\n         node_id: _bt_config.blocktronNodeId,\n         node_address: process.argv[3] ? process.argv[3] : 'http://127.0.0.1:' + port,\n         environment: env,\n         os: process.platform,\n         cpu_arch: process.arch,\n         process_versions: {\n            node_version: process.versions.node,\n            v8_version: process.versions.v8\n         }\n      }\n   };\n   res.json(response);\n});\n\nmodule.exports = indexRouter;","'use strict';\n\n/**\r\n * blocktron mine router and controller\r\n * @module routers:mineRouter\r\n */\nvar express = require('express');\nvar mineRouter = express.Router();\n\n/**\r\n * The simplified HTTP request client 'request' with Promise support.\r\n * Powered by Bluebird.\r\n * `request-promise` returns regular Promises/A+ compliant promises\r\n * and can be assimilated by any compatible promise library.\r\n * @see {@link https://www.npmjs.com/package/request-promise|Request-Promise}\r\n */\nvar request = require('request-promise');\n\n/**\r\n * Mine a block.\r\n * @function\r\n * @name get/mine\r\n * @memberof routers:mineRoute\r\n * @param {String} path - Express route path\r\n * @param {Callback} middleware - Express middleware callback\r\n */\nmineRouter.get('/', function (req, res, next) {\n  /**\r\n   * Get the last block from the chain\r\n   */\n  var lastBlock = blocktron.getLastBlock();\n\n  /**\r\n   * Get the hash of the that block (previousBlock)\r\n   */\n  var previousBlockHash = lastBlock['hash'];\n\n  /**\r\n   * Build the current block's data\r\n   * @constant currentBlockData\r\n   * @type {Object}\r\n   * @memberof routers:mineRoute\r\n   * @param {Array} transactions - List of pending transactions\r\n   * @param {Number} index - The chronological position of this block on the chain\r\n   */\n  var currentBlockData = {\n    transactions: blocktron.pendingTransactions,\n    index: lastBlock['index'] + 1\n  };\n\n  /**\r\n   * Get the valid nonce value using the Proof Of Work Algorithm\r\n   */\n  var nonce = blocktron.proofOfWork(previousBlockHash, currentBlockData);\n\n  /**\r\n   * Generate the hash of the block data\r\n   */\n  var blockHash = blocktron.hashBlock(previousBlockHash, currentBlockData, nonce);\n\n  /**\r\n   * Create the new block (Mining the new block to the blockchain)\r\n   */\n  var newBlock = blocktron.createNewBlock(nonce, previousBlockHash, blockHash);\n\n  /**\r\n   * Array to hold the request promise objects\r\n   */\n  var requestPromises = [];\n\n  /**\r\n   * Broadcast mined blocks to all nodes\r\n   */\n  blocktron.networkNodes.forEach(function (networkNodeUrl) {\n    /**\r\n     * Construct the request\r\n     */\n    var requestOptions = {\n      uri: networkNodeUrl + '/receiveNewBlock',\n      method: 'POST',\n      body: {\n        newBlock: newBlock\n      },\n      json: true\n    };\n\n    /**\r\n     * Push request promise objects into request promise array\r\n     */\n    requestPromises.push(request(requestOptions));\n  });\n\n  /**\r\n   * Resolve all request promise objects and then send appropriate response\r\n   */\n  Promise.all(requestPromises)\n\n  /**\r\n   * Once resolved send the response\r\n   */\n  .then(function (data) {\n    /**\r\n     * Reward the miner with the standard reward value\r\n     * Construct the request\r\n     */\n    var requestOptions = {\n      uri: blocktron.currentNodeUrl + '/transaction/broadcast',\n      method: 'POST',\n      body: {\n        amount: _bt_config.rewardValue,\n        sender: _bt_config.rewardSenderAddress,\n        receiver: _bt_config.blocktronNodeId\n      },\n      json: true\n    };\n\n    /**\r\n     * Return the request promise\r\n     */\n    return request(requestOptions);\n  }).then(function (data) {\n    /**\r\n     * Set appropriate status code\r\n     */\n    res.status(201);\n\n    /**\r\n     * Construct the response object and send it\r\n     * @const response\r\n     * @type {Object}\r\n     * @memberof routers:mineRoute\r\n     * @param {String} status - The status of the operation\r\n     * @param {Number} code - The HTTP response status code\r\n     * @param {String} message - The message string\r\n     * @param {Object} blockData - The newly mined block's data\r\n     */\n    var response = {\n      status: 'success',\n      code: res.statusCode,\n      message: 'New block mined and broadcasted successfully',\n      blockData: newBlock\n    };\n    res.json(response);\n  }).catch(function (error) {\n    log.error('Block mine and broadcast failed due to: ' + error);\n  });\n});\n\nmodule.exports = mineRouter;","'use strict';\n\n/**\r\n * blocktron mine router and controller\r\n * @module routers:receiveNewBlockRouter\r\n */\nvar express = require('express');\nvar receiveNewBlockRouter = express.Router();\n\n/**\r\n * Receive a new block.\r\n * @function\r\n * @name get/receiveNewBlock\r\n * @memberof routers:receiveNewBlockRouter\r\n * @param {String} path - Express route path\r\n * @param {Callback} middleware - Express middleware callback\r\n */\nreceiveNewBlockRouter.post('/', function (req, res, next) {\n  /**\r\n   * Validate the request for new block\r\n   */\n  if (!req || !req.body || !req.body.newBlock) {\n    /**\r\n     * Log error if bad request\r\n     */\n    log.error('Block data missing');\n\n    /**\r\n     * Set appropriate status code for response\r\n     */\n    res.status(400);\n\n    /**\r\n     * Construct the reponse and send it\r\n     * @const response\r\n     * @type {Object}\r\n     * @memberof routers:receiveNewBlockRouter\r\n     * @param {String} status - The status of the operation\r\n     * @param {Number} code - The HTTP response status code\r\n     * @param {String} message - The message string\r\n     */\n    var response = {\n      status: 'Bad request',\n      code: res.statusCode,\n      message: 'Invalid data type or missing data'\n    };\n    res.json(response);\n  } else {\n    /**\r\n     * Read the new block data from request\r\n     */\n    var newBlock = req.body.newBlock;\n\n    /**\r\n     * Get the last block from this node's chain\r\n     */\n    var lastBlock = blocktron.getLastBlock();\n\n    /**\r\n     * Check new block's previous hash is equal to last block's hash or not\r\n     */\n    var validHash = lastBlock.hash === newBlock.previousHash;\n\n    /**\r\n     * Check if the new block's index is valid\r\n     */\n    var validIndex = lastBlock['index'] + 1 === newBlock['index'];\n\n    /**\r\n     * Check for valid hash and index of the new block\r\n     */\n    if (validHash && validIndex) {\n      /**\r\n       * Push the valid block into the blockchain\r\n       */\n      blocktron.chain.push(newBlock);\n\n      /**\r\n       * Empty the pending transactions array\r\n       */\n      blocktron.pendingTransactions = [];\n\n      /**\r\n       * Set appropriate response status code\r\n       */\n      res.status(201);\n\n      /**\r\n       * Construct the response object and send it\r\n       * @const response\r\n       * @type {Object}\r\n       * @memberof routers:receiveNewBlockRouter\r\n       * @param {String} status - The status of the operation\r\n       * @param {Number} code - The HTTP response status code\r\n       * @param {String} message - The message string\r\n       * @param {Object} blockData - The newly received block's data\r\n       */\n      var _response = {\n        status: 'success',\n        code: res.statusCode,\n        message: 'New block received and accepted',\n        blockData: newBlock\n      };\n      res.json(_response);\n    } else {\n      /**\r\n       * Set appropriate status code for response\r\n       */\n      res.status(400);\n\n      /**\r\n       * Construct the reponse and send it\r\n       * @const response\r\n       * @type {Object}\r\n       * @memberof routers:receiveNewBlockRouter\r\n       * @param {String} status - The status of the operation\r\n       * @param {Number} code - The HTTP response status code\r\n       * @param {String} message - The message string\r\n       */\n      var _response2 = {\n        status: 'Bad request',\n        code: res.statusCode,\n        message: 'Invalid block data'\n      };\n      res.json(_response2);\n    }\n  }\n});\n\nmodule.exports = receiveNewBlockRouter;","'use strict';\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\r\n * register and broadcast nodes router and controller\r\n * @module routers:registerAndBroadcastRouter\r\n */\nvar express = require('express');\nvar registerAndBroadcastRouter = express.Router();\n\n/**\r\n * The simplified HTTP request client 'request' with Promise support.\r\n * Powered by Bluebird.\r\n * `request-promise` returns regular Promises/A+ compliant promises\r\n * and can be assimilated by any compatible promise library.\r\n * @see {@link https://www.npmjs.com/package/request-promise|Request-Promise}\r\n */\nvar request = require('request-promise');\n\n/**\r\n * POST a url to register and broadcast it to other nodes\r\n * @function\r\n * @name post/registerAndBroadcast\r\n * @memberof routers:registerAndBroadcastRouter\r\n * @param {String} path - Express route path\r\n * @param {Callback} middleware - Express middleware callback\r\n */\nregisterAndBroadcastRouter.post('/', function (req, res, next) {\n  /**\r\n   * Get the new node's url from request body\r\n   */\n  var newNodeUrl = req.body.newNodeUrl;\n\n  /**\r\n   * Check whether current node's url is equal to new node url\r\n   * if not equal, constant holds a 'true'\r\n   * @const notCurrentNode\r\n   * @type {Boolean}\r\n   */\n  var notCurrentNode = blocktron.currentNodeUrl !== newNodeUrl;\n\n  /**\r\n   * Check whether the node url is already present in the registry or is it current node's url\r\n   * TODO: Also check whether the node url is accessible.\r\n   */\n  if (blocktron.isNewNode(newNodeUrl) && notCurrentNode) {\n    /**\r\n     * If url is new, push the url to registry\r\n     */\n    blocktron.networkNodes.push(newNodeUrl);\n\n    /**\r\n     * Array to hold the promise objects of nodes registration\r\n     */\n    var registerNodesPromises = [];\n\n    /**\r\n     * Register each node url in the networkNodes array\r\n     */\n    blocktron.networkNodes.forEach(function (networkNodeUrl) {\n      /**\r\n       * Construct the options for request-promise\r\n       * @const requestOptions\r\n       * @type {Object}\r\n       * @memberof routers:registerAndBroadcastRouter\r\n       * @param {String} uri - The uri to request to\r\n       * @param {String} method - The HTTP method to use\r\n       * @param {Object} body - The request body object\r\n       * @param {Boolean} json - The type of request body\r\n       */\n      var requestOptions = {\n        uri: networkNodeUrl + '/registerNode',\n        method: 'POST',\n        body: {\n          newNodeUrl: newNodeUrl\n        },\n        json: true\n      };\n\n      /**\r\n       * Push each promise object returned from `request` into the promise array\r\n       */\n      registerNodesPromises.push(request(requestOptions));\n    });\n\n    /**\r\n     * Resolve all promises sequentially and then register them in bulk\r\n     */\n    Promise.all(registerNodesPromises).then(function (data) {\n      /**\r\n       * Construct the bulk registration request and send it\r\n       * @const bulkRegisterOptions\r\n       * @type {Object}\r\n       * @memberof routers:registerAndBroadcastRouter\r\n       * @param {String} uri - The uri to request to\r\n       * @param {String} method - The HTTP method to use\r\n       * @param {Object} body - The request body object\r\n       * @param {Boolean} json - The type of request body\r\n       */\n      var bulkRegisterOptions = {\n        uri: newNodeUrl + '/registerNodesBulk',\n        method: 'POST',\n        body: {\n          allNetworkNodes: [].concat(_toConsumableArray(blocktron.networkNodes), [blocktron.currentNodeUrl])\n        },\n        json: true\n      };\n\n      /**\r\n       * Return the bulk registration promise object\r\n       */\n      return request(bulkRegisterOptions);\n    }).then(function (data) {\n      /**\r\n       * Once bulk registration is resolved set appropriate header and send response\r\n       */\n      res.status(201);\n\n      /**\r\n       * Construct the reponse and send it\r\n       * @const response\r\n       * @type {Object}\r\n       * @memberof routers:registerAndBroadcastRouter\r\n       * @param {String} status - The status of the operation\r\n       * @param {Number} code - The HTTP response status code\r\n       * @param {String} message - The message string\r\n       */\n      var response = {\n        status: 'success',\n        code: res.statusCode,\n        message: 'New nodes registered with the network'\n      };\n      res.json(response);\n    }).catch(function (error) {\n      /**\r\n       * Catch promise reject error\r\n       */\n      log.error('Nodes registration failed due to: ' + error);\n\n      /**\r\n       * Set response status to 409 to represent resource conflict\r\n       */\n      res.status(409);\n\n      /**\r\n       * Construct response and send it\r\n       * @const response\r\n       * @type {Object}\r\n       * @memberof routers:registerAndBroadcastRouter\r\n       * @param {String} status - The status of the operation\r\n       * @param {Number} code - The HTTP response status code\r\n       * @param {String} message - The message string\r\n       */\n      var response = {\n        status: 'resource conflict',\n        code: res.statusCode,\n        message: 'Given node url: ' + newNodeUrl + ', is a conflicting value'\n      };\n      res.json(response);\n    });\n  } else {\n    /**\r\n     * Set response status to 409 to represent resource conflict\r\n     */\n    res.status(409);\n\n    /**\r\n     * Construct response and send it\r\n     * @const response\r\n     * @type {Object}\r\n     * @memberof routers:registerAndBroadcastRouter\r\n     * @param {String} status - The status of the operation\r\n     * @param {Number} code - The HTTP response status code\r\n     * @param {String} message - The message string\r\n     */\n    var response = {\n      status: 'resource conflict',\n      code: res.statusCode,\n      message: 'Given node url: ' + newNodeUrl + ', is already present in registry or is a conflicting value'\n    };\n    res.json(response);\n  }\n});\n\nmodule.exports = registerAndBroadcastRouter;","'use strict';\n\n/**\r\n * register node router and controller\r\n * @module routers:registerNodeRouter\r\n */\nvar express = require('express');\nvar registerNodeRouter = express.Router();\n\n/**\r\n * POST a url to register it with node\r\n * @function\r\n * @name post/registerNode\r\n * @memberof routers:registerNodeRouter\r\n * @param {String} path - Express route path\r\n * @param {Callback} middleware - Express middleware callback\r\n */\nregisterNodeRouter.post('/', function (req, res, next) {\n  /**\r\n   * Get the new node's url from request body\r\n   */\n  var newNodeUrl = req.body.newNodeUrl;\n\n  /**\r\n   * Check whether current node's url is equal to new node url\r\n   * if not equal, constant holds a 'true'\r\n   * @const notCurrentNode\r\n   * @type {Boolean}\r\n   */\n  var notCurrentNode = blocktron.currentNodeUrl !== newNodeUrl;\n\n  /**\r\n   * Check whether node url already exists in data structure, and\r\n   * also check whether current node's url is equal to new node url\r\n   */\n  if (blocktron.isNewNode(newNodeUrl) && notCurrentNode) {\n    /**\r\n     * then push the new url to networkNodes array\r\n     */\n    blocktron.networkNodes.push(newNodeUrl);\n  } else {\n    /**\r\n     * log error denoting the duplication or conflicting value\r\n     */\n    log.error('Given url: ' + newNodeUrl + ' rejected, it is already present or is a conflicting value');\n  }\n\n  /**\r\n   * Set appropriate response status code\r\n   */\n  res.status(201);\n\n  /**\r\n   * Construct the reponse and send it\r\n   * @const response\r\n   * @type {Object}\r\n   * @memberof routers:registerNodeRouter\r\n   * @param {String} status - The status of the operation\r\n   * @param {Number} code - The HTTP response status code\r\n   * @param {String} message - The message string\r\n   */\n  var response = {\n    status: 'success',\n    code: res.statusCode,\n    message: 'New node registered successfully'\n  };\n  res.json(response);\n});\n\nmodule.exports = registerNodeRouter;","'use strict';\n\n/**\r\n * register nodes in bulk router and controller\r\n * @module routers:registerNodesBulkRouter\r\n */\nvar express = require('express');\nvar registerNodesBulkRouter = express.Router();\n\n/**\r\n * POST multiple node urls to register them all at once\r\n * @function\r\n * @name post/registerNodesBulk\r\n * @memberof routers:registerNodesBulkRouter\r\n * @param {String} path - Express route path\r\n * @param {Callback} middleware - Express middleware callback\r\n */\nregisterNodesBulkRouter.post('/', function (req, res, next) {\n  /**\r\n   * Validate the request for invalid data\r\n   */\n  if (!req.body || !req.body.allNetworkNodes) {\n    /**\r\n     * log error\r\n     */\n    log.error('Bad request, given request body is either empty or contains invalid data');\n\n    /**\r\n     * Set appropriate status code for response\r\n     */\n    res.status(400);\n\n    /**\r\n     * Construct the reponse and send it\r\n     * @const response\r\n     * @type {Object}\r\n     * @memberof routers:registerNodesBulkRouter\r\n     * @param {String} status - The status of the operation\r\n     * @param {Number} code - The HTTP response status code\r\n     * @param {String} message - The message string\r\n     */\n    var response = {\n      status: 'Bad request',\n      code: res.statusCode,\n      message: 'Invalid data type or missing data'\n    };\n    res.json(response);\n  } else {\n    /**\r\n     * Get the network nodes url list from the request body\r\n     */\n    var allNetworkNodes = req.body.allNetworkNodes;\n\n    /**\r\n     * Iterate and add each node url to networkNodes array\r\n     * also validate each url for duplication\r\n     */\n    allNetworkNodes.forEach(function (networkNodeUrl) {\n      /**\r\n       * Check whether current node's url is equal to network node url\r\n       * if not equal, constant holds a 'true'\r\n       * @const notCurrentNode\r\n       * @type {Boolean}\r\n       */\n      var notCurrentNode = blocktron.currentNodeUrl !== networkNodeUrl;\n\n      /**\r\n       * Check whether node url already exists in data structure, and\r\n       * also check whether current node's url is equal to network node url\r\n       */\n      if (blocktron.isNewNode(networkNodeUrl) && notCurrentNode) {\n        /**\r\n         * then push the new url to networkNodes array\r\n         */\n        blocktron.networkNodes.push(networkNodeUrl);\n      } else {\n        /**\r\n         * log error denoting the duplication or conflicting value\r\n         */\n        log.error('Given url: ' + networkNodeUrl + ' rejected, it is already present or is a conflicting value');\n      }\n    });\n\n    /**\r\n     * Set appropriate status code for response\r\n     */\n    res.status(201);\n\n    /**\r\n     * Construct the reponse and send it\r\n     * @const response\r\n     * @type {Object}\r\n     * @memberof routers:registerNodesBulkRouter\r\n     * @param {String} status - The status of the operation\r\n     * @param {Number} code - The HTTP response status code\r\n     * @param {String} message - The message string\r\n     */\n    var _response = {\n      status: 'success',\n      code: res.statusCode,\n      message: 'Bulk registration of nodes successful'\n    };\n    res.json(_response);\n  }\n});\n\nmodule.exports = registerNodesBulkRouter;","'use strict';\n\n/**\r\n * blocktron transaction router and controller\r\n * @module routers:transactionRouter\r\n */\nvar express = require('express');\nvar transactionRouter = express.Router();\n\n/**\r\n * POST a transaction\r\n * @function\r\n * @name post/transaction\r\n * @memberof routers:transactionRouter\r\n * @param {String} path - Express route path\r\n * @param {Callback} middleware - Express middleware callback\r\n */\ntransactionRouter.post('/', function (req, res, next) {\n  /**\r\n   * Validate the transaction parameter\r\n   */\n  if (req.body) {\n    /**\r\n     * Create a transaction with the request parameters.\r\n     */\n    var blockIndex = blocktron.addTransactionToPendingTransaction(req.body);\n\n    /**\r\n     * Construct the response object and send it\r\n     * @const response\r\n     * @type {Object}\r\n     * @memberof routers:transactionRouter\r\n     * @param {String} status - The status of the operation\r\n     * @param {Number} code - The HTTP response status code\r\n     * @param {String} message - The message string\r\n     */\n    var response = {\n      status: 'success',\n      code: res.statusCode,\n      message: 'Transaction will be added to the block: ' + blockIndex\n    };\n    res.json(response);\n  } else {\n    /**\r\n     * log error\r\n     */\n    log.error('Cannot create a transaction without required parameter');\n  }\n});\n\nmodule.exports = transactionRouter;"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A","sourceRoot":""}